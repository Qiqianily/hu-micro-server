# ========== Docker æ„å»ºéƒ¨ç½²å·¥ä½œæµ ==========
name: ğŸ³ Docker Build & Deploy

# ========== è§¦å‘æ¡ä»¶ ==========
on:
  push:
    tags:
      - "v*" # ç‰ˆæœ¬æ ‡ç­¾è§¦å‘
  workflow_dispatch: # æ‰‹åŠ¨è§¦å‘
    inputs:
      version:
        description: "éƒ¨ç½²ç‰ˆæœ¬ (é»˜è®¤: latest)"
        required: false
        default: "latest"

# ========== ç¯å¢ƒå˜é‡é…ç½® ==========
env:
  # ğŸ”§ é¡¹ç›®é…ç½® (æŒ‰éœ€ä¿®æ”¹)
  PROJECT_NAME: "hu_server"
  GRPC_SERVER_BINARY: "hu_server_grpc"
  HTTP_SERVER_BINARY: "hu_server_http"
  RUST_TARGET: "x86_64-unknown-linux-musl"

  # ğŸ“ ç›®å½•é…ç½® (æŒ‰éœ€ä¿®æ”¹)
  REMOTE_DEPLOY_DIR: "/hu-server/deploy/"
  REMOTE_CONFIG_DIR: "/hu-server/deploy/config/"

  # ğŸ³ Docker é…ç½®
  DOCKER_COMPOSE_FILE: "docker-compose.yml"
  GRPC_SERVER_IMAGE: "hu_server_grpc"
  HTTP_SERVER_IMAGE: "hu_server_http"
  GRPC_DOCKER_FILE: "Dockerfile.grpc"
  HTTP_DOCKER_FILE: "Dockerfile.http"
  GRPC_PORT: 50001
  HTTP_PORT: 8888
  ENV_FILE: ".env_prod"
  CONFIG_FILE: "prod.yml"

# ========== å·¥ä½œæµå®šä¹‰ ==========
jobs:
  # é˜¶æ®µ1: æ„å»ºé™æ€äºŒè¿›åˆ¶æ–‡ä»¶
  build:
    name: ğŸ”¨ Build a static binary file
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.VERSION }}
      is_tag: ${{ steps.version.outputs.IS_TAG }}
    steps:
      # æ­¥éª¤1: æ£€å‡ºä»£ç 
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
      # æ­¥éª¤2: å®‰è£… Protoc
      - name: ğŸ—ï¸ Install Protoc
        uses: arduino/setup-protoc@v3
      # æ­¥éª¤3: è®¾ç½® Rust musl ç¯å¢ƒ
      - name: âš™ï¸ Setup Rust Musl Environment
        run: |
          # å®‰è£… Rust
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
          source $HOME/.cargo/env

          # å®‰è£… musl ç›®æ ‡
          rustup target add x86_64-unknown-linux-musl

          # å®‰è£… musl å·¥å…·
          sudo apt-get update
          sudo apt-get install -y musl-tools musl-dev

          # é…ç½® Cargo
          mkdir -p .cargo
          cat > .cargo/config.toml << EOF
          [target.x86_64-unknown-linux-musl]
          linker = "x86_64-linux-musl-gcc"
          EOF

          echo "âœ… Rust musl ç¯å¢ƒè®¾ç½®å®Œæˆ"

      # æ­¥éª¤4: ç¼“å­˜ä¾èµ–
      - name: ğŸ“¦ Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      # æ­¥éª¤5: æ„å»ºé™æ€äºŒè¿›åˆ¶æ–‡ä»¶
      - name: ğŸ”¨ Build static binary
        run: |
          source $HOME/.cargo/env
          export RUSTFLAGS="-C linker=x86_64-linux-musl-gcc"

          echo "ğŸ—ï¸ å¼€å§‹æ„å»º..."
          cargo build --release --bin ${{ env.GRPC_SERVER_BINARY }} --target ${{ env.RUST_TARGET }}
          cargo build --release --bin ${{ env.HTTP_SERVER_BINARY }} --target ${{ env.RUST_TARGET }}

          # éªŒè¯æ„å»ºç»“æœ - åˆ†åˆ«æ£€æŸ¥ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
          GRPC_BINARY_PATH="target/${{ env.RUST_TARGET }}/release/${{ env.GRPC_SERVER_BINARY }}"
          HTTP_BINARY_PATH="target/${{ env.RUST_TARGET }}/release/${{ env.HTTP_SERVER_BINARY }}"

          # éªŒè¯ gRPC æœåŠ¡å™¨
          if [ -f "$GRPC_BINARY_PATH" ]; then
            echo "âœ… gRPC æœåŠ¡å™¨æ„å»ºæˆåŠŸ: $GRPC_BINARY_PATH"
            echo "ğŸ“Š æ–‡ä»¶ä¿¡æ¯:"
            file "$GRPC_BINARY_PATH"
            echo "ğŸ’¾ æ–‡ä»¶å¤§å°:"
            du -h "$GRPC_BINARY_PATH"
          else
            echo "âŒ gRPC æœåŠ¡å™¨æ„å»ºå¤±è´¥: æ–‡ä»¶ä¸å­˜åœ¨"
            exit 1
          fi

          # éªŒè¯ HTTP æœåŠ¡å™¨
          if [ -f "$HTTP_BINARY_PATH" ]; then
            echo "âœ… HTTP æœåŠ¡å™¨æ„å»ºæˆåŠŸ: $HTTP_BINARY_PATH"
            echo "ğŸ“Š æ–‡ä»¶ä¿¡æ¯:"
            file "$HTTP_BINARY_PATH"
            echo "ğŸ’¾ æ–‡ä»¶å¤§å°:"
            du -h "$HTTP_BINARY_PATH"
          else
            echo "âŒ HTTP æœåŠ¡å™¨æ„å»ºå¤±è´¥: æ–‡ä»¶ä¸å­˜åœ¨"
            exit 1
          fi

      # æ­¥éª¤6: æå–ç‰ˆæœ¬å·
      - name: ğŸ·ï¸ Extract version tag
        id: version
        run: |
          if [[ "${{ github.ref }}" =~ ^refs/tags/v([0-9]+\.[0-9]+(\.[0-9]+)*) ]]; then
            VERSION="${BASH_REMATCH[1]}"
            IS_TAG="true"
            echo "âœ… æå–åˆ°ç‰ˆæœ¬å·: $VERSION"
          elif [[ "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            IS_TAG="false"
          else
            VERSION="latest"
            IS_TAG="false"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "IS_TAG=$IS_TAG" >> $GITHUB_OUTPUT
          echo "âœ… ä½¿ç”¨ç‰ˆæœ¬: $VERSION"

      # æ­¥éª¤7: ä¸ºä¸¤ä¸ªæœåŠ¡åˆ†åˆ«å‡†å¤‡éƒ¨ç½²åŒ…
      - name: ğŸ“¦ Prepare deployment package
        run: |
          # åˆ›å»ºéƒ¨ç½²ç›®å½•
          mkdir -p deploy-package

          echo "ğŸ“ å‡†å¤‡éƒ¨ç½²æ–‡ä»¶..."

          # 1. å¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
          cp -v "target/${{ env.RUST_TARGET }}/release/${{ env.GRPC_SERVER_BINARY}}" deploy-package/
          cp -v "target/${{ env.RUST_TARGET }}/release/${{ env.HTTP_SERVER_BINARY}}" deploy-package/

          # 2. è®¾ç½®æ‰§è¡Œæƒé™
          chmod +x deploy-package/${{ env.GRPC_SERVER_BINARY}} deploy-package/${{ env.HTTP_SERVER_BINARY}}

          # 3. å¤åˆ¶ Dockerfile
          cp -v ${{ env.GRPC_DOCKER_FILE}} ${{ env.HTTP_DOCKER_FILE}} ${{ env.DOCKER_COMPOSE_FILE}} deploy-package/

          # 4. å¤åˆ¶é…ç½®æ–‡ä»¶
          mkdir -p deploy-package/config
          cp -v ${{ env.CONFIG_FILE }} deploy-package/config/ 2>/dev/null || true

          # 5. åˆ›å»º .env ç¯å¢ƒæ–‡ä»¶
          echo "âœ… åˆ›å»º .env ç¯å¢ƒæ–‡ä»¶"
          cat > deploy-package/${{ env.ENV_FILE }} << EOF
          CURRENT_VERSION=${{ env.VERSION }}
          GRPC_SERVER_IMAGE_NAME=${{ env.GRPC_SERVER_IMAGE }}
          HTTP_SERVER_IMAGE_NAME=${{ env.HTTP_SERVER_IMAGE }}
          GRPC_PORT=${{ env.GRPC_PORT }}
          HTTP_PORT=${{ env.HTTP_PORT }}
          RUST_LOG=info
          EOF

          echo "ğŸ“ éƒ¨ç½²åŒ…å†…å®¹:"
          ls -la deploy-package/

          # åˆ›å»ºå‹ç¼©åŒ…
          tar czf deployment-${{ env.VERSION }}.tar.gz -C deploy-package .

      # æ­¥éª¤8: ä¸Šä¼ æ„å»ºäº§ç‰©
      - name: ğŸ“¤ Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-${{ env.VERSION }}
          path: deployment-${{ env.VERSION }}.tar.gz
          retention-days: 1

  # é˜¶æ®µ2: éƒ¨ç½²åˆ°æœåŠ¡å™¨
  deploy:
    name: ğŸš€ Deploy to the remote server
    runs-on: ubuntu-latest
    needs: build
    environment: production

    steps:
      # æ­¥éª¤1: ä¸‹è½½æ„å»ºäº§ç‰©
      - name: ğŸ“¥ Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-${{ needs.build.outputs.version }}

      # æ­¥éª¤2: è®¾ç½® SSH
      - name: ğŸ”‘ Setup SSH
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      # æ­¥éª¤3: æµ‹è¯• SSH è¿æ¥
      - name: ğŸ§ª Test SSH connection
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }} \
            "echo 'âœ… SSH è¿æ¥æˆåŠŸ' && docker --version && docker compose version"

      # æ­¥éª¤4: ä¸Šä¼ æ„å»ºåŒ…
      - name: ğŸ“¤ Upload to server
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ secrets.REMOTE_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "deployment-${{ needs.build.outputs.version }}.tar.gz"
          target: ${{ env.REMOTE_DEPLOY_DIR }}
          timeout: 300s

      # æ­¥éª¤5: æ‰§è¡Œè¿œç¨‹éƒ¨ç½²
      - name: ğŸš€ Execute deployment
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.REMOTE_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          timeout: 10m
          script: |
            set -e
            cd ${{ env.REMOTE_DEPLOY_DIR }}

            echo "ğŸ”§ å¼€å§‹éƒ¨ç½²æµç¨‹..."

            # åœæ­¢ç°æœ‰æœåŠ¡
            docker compose down 2>/dev/null || echo "âš ï¸ æ— è¿è¡Œä¸­çš„æœåŠ¡"

            # æ¸…ç†æ—§æ–‡ä»¶
            rm -rf ${{ env.GRPC_SERVER_BINARY }} ${{ env.HTTP_SERVER_BINARY }} ${{ env.DOCKER_COMPOSE_FILE }} ${{ env.ENV_FILE }} ./config/${{ env.CONFIG_FILE }} ${{ env.GRPC_DOCKER_FILE }} ${{ env.HTTP_DOCKER_FILE }} deploy-package

            # æ¸…é™¤ tar.gz æ–‡ä»¶
            echo "ğŸ“¦ æ¸…ç†æ—§çš„éƒ¨ç½²åŒ…..."
            KEEP_COUNT=2

            # è·å–æ–‡ä»¶åˆ—è¡¨å¹¶æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
            files=($(ls -t deployment-*.tar.gz 2>/dev/null))

            if [ ${#files[@]} -le $KEEP_COUNT ]; then
                echo "ğŸ“ æ–‡ä»¶æ•°é‡ (${#files[@]}) ä¸è¶…è¿‡ä¿ç•™æ•°é‡ ($KEEP_COUNT)ï¼Œæ— éœ€æ¸…ç†"
                exit 0
            fi

            echo "ğŸ“Š å‘ç° ${#files[@]} ä¸ªéƒ¨ç½²åŒ…æ–‡ä»¶ï¼Œä¿ç•™æœ€æ–°çš„ $KEEP_COUNT ä¸ª"

            # åˆ é™¤æ—§æ–‡ä»¶
            for ((i=KEEP_COUNT; i<${#files[@]}; i++)); do
                echo "ğŸ—‘ï¸  åˆ é™¤: ${files[i]}"
                rm -f "${files[i]}"
            done

            echo "âœ… æ¸…ç†å®Œæˆï¼å‰©ä½™æ–‡ä»¶:"
            ls -lh deployment-*.tar.gz 2>/dev/null || echo "ğŸ“­ æ²¡æœ‰æ‰¾åˆ° deployment-*.tar.gz æ–‡ä»¶"

            # è§£å‹éƒ¨ç½²åŒ…
            tar xzf deployment-${{ needs.build.outputs.version }}.tar.gz

            # éªŒè¯å¿…è¦æ–‡ä»¶
            for file in ${{ env.GRPC_SERVER_BINARY }} ${{ env.HTTP_SERVER_BINARY }} ${{ env.DOCKER_COMPOSE_FILE }} ./config/${{ env.CONFIG_FILE }} ${{ env.GRPC_DOCKER_FILE }} ${{ env.HTTP_DOCKER_FILE }} ${{ env.ENV_FILE }}; do
              [ -f "$file" ] || { echo "âŒ æ–‡ä»¶ç¼ºå¤±: $file"; exit 1; }
            done

            chmod +x "${{ env.GRPC_SERVER_BINARY }}"
            chmod +x "${{ env.HTTP_SERVER_BINARY }}"

            # å¤åˆ¶é…ç½®æ–‡ä»¶
            mkdir -p ${{ env.REMOTE_CONFIG_DIR }}
            [ -f "${{ env.CONFIG_FILE }}" ] && cp -f ${{ env.CONFIG_FILE }} ${{ env.REMOTE_CONFIG_DIR }}prod.yml || true

            # æ„å»ºå¹¶å¯åŠ¨æœåŠ¡
            docker compose --env-file ${{ env.ENV_FILE }} -f ${{ env.DOCKER_COMPOSE_FILE }} build --no-cache
            docker compose --env-file ${{ env.ENV_FILE }} -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

            # ç­‰å¾…æœåŠ¡å¯åŠ¨
            sleep 10

            # éªŒè¯æœåŠ¡çŠ¶æ€
            echo "ğŸ“Š æœåŠ¡çŠ¶æ€:"
            docker ps --filter "name=${{ env.PROJECT_NAME }}"

            # # æ¸…ç†æ—§é•œåƒ
            # echo "ğŸ§¹ æ¸…ç†æ—§é•œåƒ..."
            # CURRENT_IMAGE=$(docker inspect ${{ env.PROJECT_NAME }} --format '{{.Config.Image}}' 2>/dev/null || echo "")
            # [ -n "$CURRENT_IMAGE" ] && echo "ğŸ†• å½“å‰é•œåƒ: $CURRENT_IMAGE"

            # docker images --filter "reference=*${{ env.PROJECT_NAME }}*" --format "{{.Repository}}:{{.Tag}}" | \
            # while read -r image; do
            #   if [ "$image" != "$CURRENT_IMAGE" ] && [ -n "$image" ]; then
            #     echo "ğŸ—‘ï¸ åˆ é™¤: $image"
            #     docker rmi "$image" 2>/dev/null || echo "âš ï¸ æ— æ³•åˆ é™¤ $image"
            #   fi
            # done

            # # æ¸…ç†æ‚¬ç©ºé•œåƒ
            # docker image prune -f 2>/dev/null || true

            # echo "ğŸ‰ éƒ¨ç½²å®Œæˆ! é•œåƒæ¸…ç†å®Œæˆï¼å½“å‰è¿è¡Œç‰ˆæœ¬: ${{ needs.build.outputs.version }}"

      # æ­¥éª¤6: æ¸…ç†é•œåƒ
      - name: ğŸ“¦ æ™ºèƒ½æ¸…ç†é•œåƒ
        run: |
          echo "ğŸ§¹ æ™ºèƒ½æ¸…ç†æ—§é•œåƒï¼ˆæ¯ä¸ªæœåŠ¡ä¿ç•™æœ€æ–°ç‰ˆæœ¬ï¼‰..."

          # åªä¿ç•™æœ€æ–°ç‰ˆæœ¬
          KEEP_COUNT=1

          # å°†ç¯å¢ƒå˜é‡èµ‹å€¼ç»™å±€éƒ¨å˜é‡ï¼Œä»¥ä¾¿å¤ç”¨
          GRPC_SERVER_IMAGE="${{ env.GRPC_SERVER_IMAGE }}"
          HTTP_SERVER_IMAGE="${{ env.HTTP_SERVER_IMAGE }}"

          echo "ğŸ” ä½¿ç”¨ç¯å¢ƒå˜é‡:"
          echo "GRPC_SERVER_IMAGE: $GRPC_SERVER_IMAGE"
          echo "HTTP_SERVER_IMAGE: $HTTP_SERVER_IMAGE"
          echo ""

          echo "ğŸ“‹ æ¸…ç†å‰é•œåƒåˆ—è¡¨:"
          docker images | grep -E "hu_server_|REPOSITORY" || true
          echo ""

          # ä¸ºæ¯ä¸ªæœåŠ¡å¤„ç†
          for service in $GRPC_SERVER_IMAGE $HTTP_SERVER_IMAGE; do
            echo "ğŸ“¦ å¤„ç† $service æœåŠ¡ï¼ˆä¿ç•™æœ€æ–°ç‰ˆï¼‰..."

            # è·å–æ‰€æœ‰é•œåƒï¼ŒæŒ‰åˆ›å»ºæ—¶é—´æ’åº
            IMAGE_LIST=$(docker images --format "{{.Repository}}:{{.Tag}} {{.CreatedAt}}" | grep "^${service}:" | sort -k2 -r)

            # ç»Ÿè®¡é•œåƒæ•°é‡
            IMAGE_COUNT=$(echo "$IMAGE_LIST" | wc -l 2>/dev/null | tr -d ' ' || echo 0)

            if [ $IMAGE_COUNT -eq 0 ]; then
              echo "  â„¹ï¸  æ²¡æœ‰æ‰¾åˆ° $service çš„é•œåƒ"
              continue
            fi

            echo "  å‘ç° $IMAGE_COUNT ä¸ªé•œåƒ"

            if [ $IMAGE_COUNT -le $KEEP_COUNT ]; then
              echo "  âœ… é•œåƒæ•°é‡ä¸è¶…è¿‡ $KEEP_COUNTï¼Œè·³è¿‡æ¸…ç†"
              continue
            fi

            # æ˜¾ç¤ºé•œåƒåˆ—è¡¨
            echo "  ğŸ“Š é•œåƒåˆ—è¡¨ï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰:"
            echo "$IMAGE_LIST"

            # åˆ é™¤ä¿ç•™æ•°é‡ä¹‹å¤–çš„é•œåƒ
            echo "  ğŸ—‘ï¸  åˆ é™¤æ—§é•œåƒ:"
            echo "$IMAGE_LIST" | tail -n +$(($KEEP_COUNT + 1)) | while read -r line; do
              image_name=$(echo "$line" | awk '{print $1}')
              echo "    - $image_name"
              # å…ˆåˆ é™¤ä½¿ç”¨è¯¥é•œåƒçš„å®¹å™¨
              docker ps -a --filter "ancestor=$image_name" -q 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
              # åˆ é™¤é•œåƒ
              docker rmi -f "$image_name" 2>/dev/null || echo "      åˆ é™¤å¤±è´¥ï¼ˆå¯èƒ½å·²è¢«å¼•ç”¨ï¼‰"
            done

            echo ""
          done

          # æ¸…ç†æ‚¬ç©ºé•œåƒ
          echo "ğŸ§½ æ¸…ç†æ‚¬ç©ºé•œåƒ..."
          docker image prune -f 2>/dev/null || true

          echo "ğŸ“‹ æ¸…ç†åçš„é•œåƒåˆ—è¡¨:"
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}" | grep -E "(hu_server_|REPOSITORY)" || true

          echo ""
          echo "âœ… æ¸…ç†å®Œæˆï¼æ¯ä¸ªæœåŠ¡åªä¿ç•™æœ€æ–°çš„ $KEEP_COUNT ä¸ªé•œåƒ"
          echo "ğŸ‰ éƒ¨ç½²å®Œæˆï¼å½“å‰è¿è¡Œç‰ˆæœ¬: ${{ needs.build.outputs.version }}"
